/*
 *
 * Copyright 2015, Google Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include <map>
#include <sstream>

#include "cpp_generator_helpers.h"
#include "config.h"

#include "cpp_cb_generator.h"

namespace grpc_cpp_cb_generator {
namespace {

template <class T>
grpc::string as_string(T x) {
  std::ostringstream out;
  out << x;
  return out.str();
}

bool NoStreaming(const grpc::protobuf::MethodDescriptor *method) {
  return !method->client_streaming() && !method->server_streaming();
}

bool ClientOnlyStreaming(const grpc::protobuf::MethodDescriptor *method) {
  return method->client_streaming() && !method->server_streaming();
}

bool ServerOnlyStreaming(const grpc::protobuf::MethodDescriptor *method) {
  return !method->client_streaming() && method->server_streaming();
}

bool BidiStreaming(const grpc::protobuf::MethodDescriptor *method) {
  return method->client_streaming() && method->server_streaming();
}

grpc::string FilenameIdentifier(const grpc::string &filename) {
  grpc::string result;
  for (unsigned i = 0; i < filename.size(); i++) {
    char c = filename[i];
    if (isalnum(c)) {
      result.push_back(c);
    } else {
      static char hex[] = "0123456789abcdef";
      result.push_back('_');
      result.push_back(hex[(c >> 4) & 0xf]);
      result.push_back(hex[c & 0xf]);
    }
  }
  return result;
}
}  // namespace

grpc::string GetHeaderPrologue(const grpc::protobuf::FileDescriptor *file,
                               const Parameters &params) {
  grpc::string output;
  {
    // Scope the output stream so it closes and finalizes output to the string.
    grpc::protobuf::io::StringOutputStream output_stream(&output);
    grpc::protobuf::io::Printer printer(&output_stream, '$');
    std::map<grpc::string, grpc::string> vars;

    vars["filename"] = file->name();
    vars["filename_identifier"] = FilenameIdentifier(file->name());
    vars["filename_base"] = grpc_generator::StripProto(file->name());

    printer.Print(vars, "// Generated by the gRPC protobuf plugin.\n");
    printer.Print(vars, "// If you make any local change, they will be lost.\n");
    printer.Print(vars, "// source: $filename$\n");
    printer.Print(vars, "#ifndef GRPC_CB_$filename_identifier$__INCLUDED\n");
    printer.Print(vars, "#define GRPC_CB_$filename_identifier$__INCLUDED\n");
    printer.Print(vars, "\n");
  }
  return output;
}

grpc::string GetHeaderIncludes(const grpc::protobuf::FileDescriptor *file,
                               const Parameters &params) {
  grpc::string output;
  {
    // Scope the output stream so it closes and finalizes output to the string.
    grpc::protobuf::io::StringOutputStream output_stream(&output);
    grpc::protobuf::io::Printer printer(&output_stream, '$');
    std::map<grpc::string, grpc::string> vars;

    vars["filename"] = file->name();
    vars["filename_base"] = grpc_generator::StripProto(file->name());

    printer.Print(vars,
      "#include <grpc_cb/grpc_cb.h>  // Include all for user.\n"
      "\n"
      "#include \"$filename_base$.pb.h\"\n"
      "\n");

    if (!file->package().empty()) {
      vars["package"] = file->package();
      printer.Print(vars, "// package $package$\n");
      std::vector<grpc::string> parts =
          grpc_generator::tokenize(file->package(), ".");

      for (auto part = parts.begin(); part != parts.end(); part++) {
        vars["part"] = *part;
        printer.Print(vars, "namespace $part$ {\n");
      }
      printer.Print("\n");
    }  // if
  }  // output
  return output;
}

void PrintHeaderClientMethodPublic(
    grpc::protobuf::io::Printer *printer,
    const grpc::protobuf::MethodDescriptor *method,
    std::map<grpc::string, grpc::string> *vars) {
  (*vars)["Method"] = method->name();
  (*vars)["Request"] =
      grpc_cpp_generator::ClassName(method->input_type(), true);
  (*vars)["Response"] =
      grpc_cpp_generator::ClassName(method->output_type(), true);

  if (NoStreaming(method)) {
      printer->Print(*vars,
          "::grpc_cb::Status Sync$Method$(\n"
          "    const $Request$& request,\n"
          "    $Response$* response = nullptr);\n"
          "\n"
          "using $Method$Callback =\n"
          "    std::function<void (const $Response$& response)>;\n"
          "void Async$Method$(\n"
          "    const $Request$& request,\n"
          "    const $Method$Callback& cb = $Method$Callback(),\n"
          "    const ::grpc_cb::ErrorCallback& ecb = ::grpc_cb::ErrorCallback());\n\n");
  } else if (ClientOnlyStreaming(method)) {
      printer->Print(
          *vars,
          "using $Method$_SyncWriter =\n"
          "    ::grpc_cb::ClientSyncWriter<$Request$>;\n"
          "$Method$_SyncWriter\n"
          "Sync$Method$();\n"
          "\n"
          "using $Method$_AsyncWriter =\n"
          "    ::grpc_cb::ClientAsyncWriter<\n"
          "        $Request$,\n"
          "        $Response$>;\n"
          "$Method$_AsyncWriter\n"
          "Async$Method$();\n\n");
  } else if (ServerOnlyStreaming(method)) {
      printer->Print(
          *vars,
          "using $Method$_SyncReader =\n"
          "    ::grpc_cb::ClientSyncReader<$Response$>;\n"
          "$Method$_SyncReader\n"
          "Sync$Method$(const $Request$& request);\n"
          "\n"
          "using $Method$MsgCb = std::function<\n"
          "    void(const $Response$&)>;\n"
          "void Async$Method$(const $Request$& request,\n"
          "    const $Method$MsgCb& on_msg = $Method$MsgCb(),\n"
          "    const ::grpc_cb::StatusCb& status_cb = ::grpc_cb::StatusCb());\n\n");
  } else if (BidiStreaming(method)) {
      printer->Print(
          *vars,
          "using $Method$_SyncReaderWriter =\n"
          "    ::grpc_cb::ClientSyncReaderWriter<\n"
          "        $Request$,\n"
          "        $Response$>;\n"
          "$Method$_SyncReaderWriter\n"
          "Sync$Method$();\n"
          "\n"
          "using $Method$_AsyncReaderWriter =\n"
          "    ::grpc_cb::ClientAsyncReaderWriter<\n"
          "        $Request$,\n"
          "        $Response$>;\n"
          "$Method$_AsyncReaderWriter\n"
          "Async$Method$(const ::grpc_cb::StatusCb& status_cb);\n\n");
  }
}

void PrintHeaderServiceMethod(grpc::protobuf::io::Printer *printer,
                                 const grpc::protobuf::MethodDescriptor *method,
                                 std::map<grpc::string, grpc::string> *vars) {
  (*vars)["Method"] = method->name();
  (*vars)["Request"] =
      grpc_cpp_generator::ClassName(method->input_type(), true);
  (*vars)["Response"] =
      grpc_cpp_generator::ClassName(method->output_type(), true);
  if (NoStreaming(method)) {
    printer->Print(*vars,
        " public:\n"
        "  using $Method$_Replier = ::grpc_cb::ServerReplier<\n"
        "      $Response$>;\n"
        " private:\n"
        "  void $Method$(\n"
        "      grpc_byte_buffer& request_buffer,\n"
        "      const $Method$_Replier& replier);\n"
        " protected:\n"
        "  // Todo: virtual void $Method$(const std::string& request_buffer, replier);\n"
        "  virtual void $Method$(\n"
        "      const $Request$& request,\n"
        "      $Method$_Replier replier);\n\n");
  } else if (ClientOnlyStreaming(method)) {
    printer->Print(*vars,
        " private:\n"
        "  void $Method$(const ::grpc_cb::CallSptr& call_sptr);\n"
        " public:\n"
        "  using $Method$_Replier = ::grpc_cb::ServerReplier<\n"
        "      $Response$>;\n"
        "  using $Method$_Reader = ::grpc_cb::ServerReaderForClientOnlyStreaming<\n"
        "      $Request$, $Response$>;\n"
        "  using $Method$_ReaderSptr = std::shared_ptr<$Method$_Reader>;\n"
        " protected:\n"
        "  virtual $Method$_ReaderSptr $Method$(\n"
        "      $Method$_Replier replier);\n\n");
  } else if (ServerOnlyStreaming(method)) {
    printer->Print(*vars,
        " public:\n"
        "  using $Method$_Writer = ::grpc_cb::ServerWriter<\n"
        "      $Response$>;\n"
        " private:\n"
        "  void $Method$(grpc_byte_buffer& request_buffer,\n"
        "      const $Method$_Writer& writer);\n"
        " protected:\n"
        "  virtual void $Method$(\n"
        "      const $Request$& request,\n"
        "      $Method$_Writer writer);\n\n");
  } else if (BidiStreaming(method)) {
    printer->Print(*vars,
        " private:\n"
        "  void $Method$(const ::grpc_cb::CallSptr& call_sptr);\n"
        " public:\n"
        "  using $Method$_Writer = ::grpc_cb::ServerWriter<\n"
        "      $Response$>;\n"
        "  using $Method$_Reader = ::grpc_cb::ServerReaderForBidiStreaming<\n"
        "      $Request$, $Response$>;\n"
        "  using $Method$_ReaderSptr = std::shared_ptr<$Method$_Reader>;\n"
        " protected:\n"
        "  virtual $Method$_ReaderSptr $Method$(\n"
        "      $Method$_Writer writer);\n\n");
  }
}

void PrintHeaderService(grpc::protobuf::io::Printer *printer,
                        const grpc::protobuf::ServiceDescriptor *service,
                        std::map<grpc::string, grpc::string> *vars) {
  (*vars)["Service"] = service->name();

  printer->Print(*vars,
      "namespace $Service$ {  // service $Service$\n\n");

  printer->Print(
      "const ::google::protobuf::ServiceDescriptor& GetServiceDescriptor();\n\n");

  // Client side
  printer->Print(
      "class Stub : public ::grpc_cb::ServiceStub {\n"
      " public:\n");
  printer->Indent();
  printer->Print("explicit Stub(const ::grpc_cb::ChannelSptr& channel,\n");
  printer->Print("    const ::grpc_cb::CompletionQueueForNextSptr& cq4n_sptr = nullptr);\n");
  printer->Print("\n");
  for (int i = 0; i < service->method_count(); ++i) {
    PrintHeaderClientMethodPublic(printer, service->method(i), vars);
  }
  printer->Outdent();
  printer->Print("};  // class Stub\n");
  printer->Print("\n");

  // Server side - Synchronous
  printer->Print(
      "class Service : public ::grpc_cb::Service {\n"
      " public:\n");
  printer->Indent();
  printer->Print("Service();\n");
  printer->Print("virtual ~Service();\n");
  printer->Print("\n");
  printer->Print("virtual const std::string& GetMethodName(size_t i) const GRPC_OVERRIDE;\n");
  printer->Print("virtual void CallMethod(\n"
                  "    size_t method_index, grpc_byte_buffer* request_buffer,\n"
                  "    const ::grpc_cb::CallSptr& call_sptr) GRPC_OVERRIDE;\n\n");
  printer->Outdent();
  for (int i = 0; i < service->method_count(); ++i) {
    PrintHeaderServiceMethod(printer, service->method(i), vars);
  }
  printer->Print(" private:\n");
  printer->Indent();
  printer->Print(
      "virtual const ::google::protobuf::ServiceDescriptor& GetDescriptor()\n"
      "    const GRPC_OVERRIDE {\n"
      "  return GetServiceDescriptor();\n"
      "}\n");
  printer->Outdent();
  printer->Print("};\n");
  printer->Print(*vars,
      "\n}  // namespace $Service$\n");
}

grpc::string GetHeaderServices(const grpc::protobuf::FileDescriptor *file,
                               const Parameters &params) {
  grpc::string output;
  {
    // Scope the output stream so it closes and finalizes output to the string.
    grpc::protobuf::io::StringOutputStream output_stream(&output);
    grpc::protobuf::io::Printer printer(&output_stream, '$');
    std::map<grpc::string, grpc::string> vars;

    if (!params.services_namespace.empty()) {
      vars["services_namespace"] = params.services_namespace;
      printer.Print(vars, "\nnamespace $services_namespace$ {\n\n");
    }

    for (int i = 0; i < file->service_count(); ++i) {
      PrintHeaderService(&printer, file->service(i), &vars);
      printer.Print("\n");
    }

    if (!params.services_namespace.empty()) {
      printer.Print(vars, "}  // namespace $services_namespace$\n\n");
    }
  }
  return output;
}

grpc::string GetHeaderEpilogue(const grpc::protobuf::FileDescriptor *file,
                               const Parameters &params) {
  grpc::string output;
  {
    // Scope the output stream so it closes and finalizes output to the string.
    grpc::protobuf::io::StringOutputStream output_stream(&output);
    grpc::protobuf::io::Printer printer(&output_stream, '$');
    std::map<grpc::string, grpc::string> vars;

    vars["filename"] = file->name();
    vars["filename_identifier"] = FilenameIdentifier(file->name());

    if (!file->package().empty()) {
      std::vector<grpc::string> parts =
          grpc_generator::tokenize(file->package(), ".");

      for (auto part = parts.rbegin(); part != parts.rend(); part++) {
        vars["part"] = *part;
        printer.Print(vars, "}  // namespace $part$\n");
      }
      printer.Print(vars, "\n");
    }

    printer.Print(vars, "#endif  // GRPC_CB_$filename_identifier$__INCLUDED\n");
  }
  return output;
}

grpc::string GetSourcePrologue(const grpc::protobuf::FileDescriptor *file,
                               const Parameters &params) {
  grpc::string output;
  {
    // Scope the output stream so it closes and finalizes output to the string.
    grpc::protobuf::io::StringOutputStream output_stream(&output);
    grpc::protobuf::io::Printer printer(&output_stream, '$');
    std::map<grpc::string, grpc::string> vars;

    vars["filename"] = file->name();
    vars["filename_base"] = grpc_generator::StripProto(file->name());

    printer.Print(vars, "// Generated by the gRPC protobuf plugin.\n");
    printer.Print(vars,
                  "// If you make any local change, they will be lost.\n");
    printer.Print(vars, "// source: $filename$\n\n");
    printer.Print(vars, "#include \"$filename_base$.grpc_cb.pb.h\"\n");
    printer.Print(vars, "\n");
  }
  return output;
}

grpc::string GetSourceIncludes(const grpc::protobuf::FileDescriptor *file,
                               const Parameters &param) {
  grpc::string output;
  {
    // Scope the output stream so it closes and finalizes output to the string.
    grpc::protobuf::io::StringOutputStream output_stream(&output);
    grpc::protobuf::io::Printer printer(&output_stream, '$');
    std::map<grpc::string, grpc::string> vars;

    printer.Print("#include <google/protobuf/descriptor.h>\n");
    printer.Print("#include <google/protobuf/stubs/once.h>\n");
    printer.Print("\n");
    printer.Print("//#include <grpc_cb/impl/client/stub_helper.h>              // for StubHelper\n");
    printer.Print("//#include <grpc_cb/impl/proto_utils.h>                     // for Proto::Deserialize()\n");
    printer.Print("//#include <grpc_cb/impl/server/server_reader_cqtag.h>      // for ServerReaderCqTag\n");
    printer.Print("//#include <grpc_cb/impl/server/server_reader_writer_cqtag.h>  // for ServerReaderWriterCqTag\n");
    printer.Print("\n");

    if (!file->package().empty()) {
      std::vector<grpc::string> parts =
          grpc_generator::tokenize(file->package(), ".");

      for (auto part = parts.begin(); part != parts.end(); part++) {
        vars["part"] = *part;
        printer.Print(vars, "// package $part$\n");
        printer.Print(vars, "namespace $part$ {\n");
      }
    }

    printer.Print(vars, "\n");
  }
  return output;
}

// Return the name of the AssignDescriptors() function for a given file.
grpc::string AssignDescriptorsName(const grpc::string& filename) {
  return "AssignDesc_" + FilenameIdentifier(filename);
}

// Do message classes in this file have descriptor and reflection methods?
inline bool HasDescriptorMethods(const grpc::protobuf::FileDescriptor *file) {
  // TODO: Use GRPC_CUSTOM_FILEOPTIONS.
  return file->options().optimize_for() != google::protobuf::FileOptions::LITE_RUNTIME;
}

grpc::string GetSourceDescriptors(const grpc::protobuf::FileDescriptor *file,
                                  const Parameters &params) {
  grpc::string output;
  {
    // Scope the output stream so it closes and finalizes output to the string.
    grpc::protobuf::io::StringOutputStream output_stream(&output);
    grpc::protobuf::io::Printer printer(&output_stream, '$');
    std::map<grpc::string, grpc::string> vars;
    vars["filename"] = file->name();
    vars["AssignDescriptorsName"] = AssignDescriptorsName(file->name());

    printer.Print(vars,
      "namespace {\n"
      "\n");

    for (int i = 0; i < file->service_count(); i++) {
      vars["Service"] = file->service(i)->name();
      printer.Print(vars,
        "const ::google::protobuf::ServiceDescriptor*\n"
        "service_descriptor_$Service$ = nullptr;\n");
    }
    printer.Print("\n");

    if (HasDescriptorMethods(file)) {
      printer.Print(vars,
        "void $AssignDescriptorsName$() {\n"
        "  // Get the file's descriptor from the pool.\n"
        "  const ::google::protobuf::FileDescriptor* file =\n"
        "    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(\n"
        "      \"$filename$\");\n");
      // Note that this GOOGLE_CHECK is necessary to prevent a warning about \"file\"
      // being unused when compiling an empty .proto file.
      printer.Print(
        "  GOOGLE_CHECK(file != NULL);\n");

      // Go through all the stuff defined in this file and generated code to
      // assign the global descriptor pointers based on the file descriptor.
      for (int i = 0; i < file->service_count(); i++) {
        vars["Service"] = file->service(i)->name();
        vars["Idx"] = as_string(i);
        printer.Print(vars,
          "  service_descriptor_$Service$ = file->service($Idx$);\n");
      }

      printer.Print(vars,
        "}  // $AssignDescriptorsName$()\n"
        "\n");

      // AssignDescriptorsOnce():  The first time it is called, calls
      // AssignDescriptors().  All later times, waits for the first call to
      // complete and then returns.
      printer.Print(vars,
        "GOOGLE_PROTOBUF_DECLARE_ONCE(grpc_cb_AssignDescriptors_once_);\n"
        "inline void AssignDescriptorsOnce() {\n"
        "  ::google::protobuf::GoogleOnceInit(\n"
        "    &grpc_cb_AssignDescriptors_once_,\n"
        "    &$AssignDescriptorsName$);\n"
        "}\n"
        "\n");

      printer.Print(
        "}  // namespace\n"
        "\n");
    }  // if (HasDescriptorMethods())
  }
  return output;
}

void PrintSourceClientMethod(grpc::protobuf::io::Printer *printer,
                             const grpc::protobuf::MethodDescriptor *method,
                             std::map<grpc::string, grpc::string> *vars) {
  (*vars)["Method"] = method->name();
  (*vars)["Request"] =
      grpc_cpp_generator::ClassName(method->input_type(), true);
  (*vars)["Response"] =
      grpc_cpp_generator::ClassName(method->output_type(), true);
  if (NoStreaming(method)) {
    printer->Print(*vars,
        "::grpc_cb::Status Stub::Sync$Method$(\n"
        "    const $Request$& request,\n"
        "    $Response$* response) {\n"
        "  return ::grpc_cb::StubHelper(*this).SyncRequest(\n"
        "      method_names[0], request, response);\n"
        "}\n"
        "\n");
    printer->Print(*vars,
        "void Stub::Async$Method$(\n"
        "    const $Request$& request,\n"
        "    const $Method$Callback& cb,\n"
        "    const ::grpc_cb::ErrorCallback& ecb) {\n"
        "  ::grpc_cb::StubHelper(*this).AsyncRequest(\n"
        "      method_names[0], request, cb, ecb);\n"
        "}\n"
        "\n");
  } else if (ClientOnlyStreaming(method)) {
    printer->Print(*vars,
                   "::grpc_cb::ClientSyncWriter<$Request$>\n"
                   "Stub::Sync$Method$() {\n"
                   "  return ::grpc_cb::ClientSyncWriter<$Request$>(\n"
                   "      GetChannelSptr(), method_names[$Idx$], GetCallTimeoutMs());\n"
                   "}\n"
                   "\n"
                   "::grpc_cb::ClientAsyncWriter<\n"
                   "    $Request$,\n"
                   "    $Response$>\n"
                   "Stub::Async$Method$() {\n"
                   "  return ::grpc_cb::ClientAsyncWriter<\n"
                   "      $Request$,\n"
                   "      $Response$>(\n"
                   "          GetChannelSptr(), method_names[$Idx$], GetCompletionQueue(),\n"
                   "          GetCallTimeoutMs());\n"
                   "}\n\n");
  } else if (ServerOnlyStreaming(method)) {
    printer->Print(*vars,
                   "::grpc_cb::ClientSyncReader<$Response$>\n"
                   "Stub::Sync$Method$(const $Request$& request) {\n"
                   "  return ::grpc_cb::ClientSyncReader<$Response$>(\n"
                   "      GetChannelSptr(), method_names[$Idx$], request, GetCallTimeoutMs());\n"
                   "}\n"
                   "\n"
                   "void Stub::Async$Method$(\n"
                   "    const $Request$& request,\n"
                   "    const $Method$MsgCb& on_msg,\n"
                   "    const ::grpc_cb::StatusCb& status_cb) {\n"
                   "  ::grpc_cb::ClientAsyncReader<$Response$> reader(\n"
                   "      GetChannelSptr(), method_names[$Idx$], request, GetCompletionQueue(),\n"
                   "      GetCallTimeoutMs());\n"
                   "  reader.ReadEach(on_msg, status_cb);\n"
                   "}\n\n");
  } else if (BidiStreaming(method)) {
    printer->Print(*vars,
                   "::grpc_cb::ClientSyncReaderWriter<\n"
                   "    $Request$,\n"
                   "    $Response$>\n"
                   "Stub::Sync$Method$() {\n"
                   "  return ::grpc_cb::ClientSyncReaderWriter<\n"
                   "      $Request$,\n"
                   "      $Response$>(\n"
                   "          GetChannelSptr(), method_names[$Idx$], GetCallTimeoutMs());\n"
                   "}\n"
                   "\n"
                   "::grpc_cb::ClientAsyncReaderWriter<\n"
                   "    $Request$,\n"
                   "    $Response$>\n"
                   "Stub::Async$Method$(\n"
                   "    const ::grpc_cb::StatusCb& status_cb) {\n"
                   "  return ::grpc_cb::ClientAsyncReaderWriter<\n"
                   "      $Request$,\n"
                   "      $Response$>(\n"
                   "          GetChannelSptr(), method_names[$Idx$], GetCompletionQueue(),\n"
                   "          GetCallTimeoutMs(), status_cb);\n"
                   "}\n\n");
  }  // if
}

void PrintSourceServerMethod(grpc::protobuf::io::Printer *printer,
                             const grpc::protobuf::MethodDescriptor *method,
                             std::map<grpc::string, grpc::string> *vars) {
  (*vars)["Method"] = method->name();
  (*vars)["Request"] =
      grpc_cpp_generator::ClassName(method->input_type(), true);
  (*vars)["Response"] =
      grpc_cpp_generator::ClassName(method->output_type(), true);
  if (NoStreaming(method)) {
    printer->Print(*vars,
        "void Service::$Method$(\n"
        "    grpc_byte_buffer& request_buffer,\n"
        "    const $Method$_Replier& replier) {\n"
        "  using Request = $Request$;\n"
        "  Request request;\n"
        "  ::grpc_cb::Status status =\n"
        "      ::grpc_cb::Proto::Deserialize(\n"
        "          &request_buffer, &request, 0 /* TODO: max_message_size*/);\n"
        "  if (status.ok()) {\n"
        "    $Method$(request, replier);\n"
        "    return;\n"
        "  }\n"
        "  $Method$_Replier(\n"
        "      replier).ReplyError(status);\n"
        "}\n"
        "void Service::$Method$(\n"
        "    const $Request$& request,\n"
        "    $Method$_Replier replier) {\n"
        "  (void)request;\n"
        "  replier.ReplyError(::grpc_cb::Status::UNIMPLEMENTED);\n"
        "}\n\n");
  } else if (ClientOnlyStreaming(method)) {
    printer->Print(*vars,
        "void Service::$Method$(const ::grpc_cb::CallSptr& call_sptr) {\n"
        "  assert(call_sptr);\n"
        "  $Method$_Replier replier(call_sptr);\n"
        "  $Method$_ReaderSptr reader_sptr = $Method$(replier);\n"
        "  if (!reader_sptr) return;\n"
        "  reader_sptr->SetReplier(replier);\n"
        "\n"
        "  using CqTag = ::grpc_cb::ServerReaderCqTag<\n"
        "      $Request$>;\n"
        "  CqTag* tag = new CqTag(call_sptr, reader_sptr);\n"
        "  if (tag->Start()) return;\n"
        "\n"
        "  delete tag;\n"
        "  reader_sptr->OnError(::grpc_cb::Status::InternalError(\n"
        "      \"Failed to init server reader.\"));\n"
        "}\n"
        "\n"
        "Service::$Method$_ReaderSptr\n"
        "Service::$Method$($Method$_Replier replier) {\n"
        "  replier.ReplyError(::grpc_cb::Status::UNIMPLEMENTED);\n"
        "  return nullptr;\n"
        "}\n\n");
  } else if (ServerOnlyStreaming(method)) {
    printer->Print(*vars,
        "void Service::$Method$(grpc_byte_buffer& request_buffer,\n"
        "    const ListFeatures_Writer& writer) {\n"
        "  using Request = $Request$;\n"
        "  Request request;\n"
        "  ::grpc_cb::Status status =\n"
        "      ::grpc_cb::Proto::Deserialize(\n"
        "          &request_buffer, &request, 0 /* TODO: max_message_size*/);\n"
        "  if (status.ok()) {\n"
        "    $Method$(request, writer);\n"
        "    return;\n"
        "  }\n"
        "  writer.AsyncClose(status);\n"
        "}\n"
        "\n"
        "void Service::$Method$(\n"
        "    const $Request$& request,\n"
        "    ListFeatures_Writer writer) {\n"
        "  (void)request;\n"
        "  writer.AsyncClose(::grpc_cb::Status::UNIMPLEMENTED);\n"
        "}\n\n");
  } else if (BidiStreaming(method)) {
    printer->Print(*vars,
        "void Service::$Method$(const ::grpc_cb::CallSptr& call_sptr) {\n"
        "  assert(call_sptr);\n"
        "  $Method$_Writer writer(call_sptr);\n"
        "  $Method$_ReaderSptr reader_sptr = $Method$(writer);\n"
        "  if (!reader_sptr) return;\n"
        "  reader_sptr->SetWriter(writer);\n"
        "\n"
        "  using RwCqTag = ::grpc_cb::ServerReaderWriterCqTag<\n"
        "      $Request$>;\n"
        "  RwCqTag* tag = new RwCqTag(call_sptr, reader_sptr);\n"
        "  if (tag->Start()) return;\n"
        "\n"
        "  delete tag;\n"
        "  reader_sptr->OnError(::grpc_cb::Status::InternalError(\n"
        "      \"Failed to init server stream.\"));\n"
        "}\n"
        "\n"
        "Service::$Method$_ReaderSptr\n"
        "Service::$Method$($Method$_Writer writer) {\n"
        "  writer.AsyncClose(::grpc_cb::Status::UNIMPLEMENTED);\n"
        "  return nullptr;\n"
        "}\n\n");
  }
}

void PrintSourceServerAsyncMethod(
    grpc::protobuf::io::Printer *printer,
    const grpc::protobuf::MethodDescriptor *method,
    std::map<grpc::string, grpc::string> *vars) {
  (*vars)["Method"] = method->name();
  (*vars)["Request"] =
      grpc_cpp_generator::ClassName(method->input_type(), true);
  (*vars)["Response"] =
      grpc_cpp_generator::ClassName(method->output_type(), true);
  if (NoStreaming(method)) {
    printer->Print(
        *vars,
        "void AsyncService::Request$Method$("
        "::grpc_cb::ServerContext* context, "
        "$Request$* request, "
        "::grpc_cb::ServerAsyncResponseWriter< $Response$>* response, "
        "::grpc_cb::CompletionQueue* new_call_cq, "
        "::grpc_cb::ServerCompletionQueue* notification_cq, void *tag) {\n");
    printer->Print(*vars,
                   "  AsynchronousService::RequestAsyncUnary($Idx$, context, "
                   "request, response, new_call_cq, notification_cq, tag);\n");
    printer->Print("}\n\n");
  } else if (ClientOnlyStreaming(method)) {
    printer->Print(
        *vars,
        "void AsyncService::Request$Method$("
        "::grpc_cb::ServerContext* context, "
        "::grpc_cb::ServerAsyncReader< $Response$, $Request$>* reader, "
        "::grpc_cb::CompletionQueue* new_call_cq, "
        "::grpc_cb::ServerCompletionQueue* notification_cq, void *tag) {\n");
    printer->Print(*vars,
                   "  AsynchronousService::RequestClientStreaming($Idx$, "
                   "context, reader, new_call_cq, notification_cq, tag);\n");
    printer->Print("}\n\n");
  } else if (ServerOnlyStreaming(method)) {
    printer->Print(
        *vars,
        "void AsyncService::Request$Method$("
        "::grpc_cb::ServerContext* context, "
        "$Request$* request, "
        "::grpc_cb::ServerAsyncWriter< $Response$>* writer, "
        "::grpc_cb::CompletionQueue* new_call_cq, "
        "::grpc_cb::ServerCompletionQueue* notification_cq, void *tag) {\n");
    printer->Print(
        *vars,
        "  AsynchronousService::RequestServerStreaming($Idx$, "
        "context, request, writer, new_call_cq, notification_cq, tag);\n");
    printer->Print("}\n\n");
  } else if (BidiStreaming(method)) {
    printer->Print(
        *vars,
        "void AsyncService::Request$Method$("
        "::grpc_cb::ServerContext* context, "
        "::grpc_cb::ServerAsyncReaderWriter< $Response$, $Request$>* reader_writer, "
        "::grpc_cb::CompletionQueue* new_call_cq, "
        "::grpc_cb::ServerCompletionQueue* notification_cq, void *tag) {\n");
    printer->Print(*vars,
                   "  AsynchronousService::RequestBidiStreaming($Idx$, "
                   "context, stream, new_call_cq, notification_cq, tag);\n");
    printer->Print("}\n\n");
  }
}

static void PrintCallMethod(grpc::protobuf::io::Printer *printer,
                            const grpc::protobuf::ServiceDescriptor *service,
                            std::map<grpc::string, grpc::string> *vars) {
  printer->Print("void Service::CallMethod(\n"
                 "    size_t method_index, grpc_byte_buffer* request_buffer,\n"
                 "    const ::grpc_cb::CallSptr& call_sptr) {\n"
                 "  assert(method_index < GetMethodCount());\n"
                 "  switch (method_index) {\n");
  for (int i = 0; i < service->method_count(); ++i) {
    (*vars)["Idx"] = as_string(i);
    const grpc::protobuf::MethodDescriptor *method = service->method(i);
    (*vars)["Method"] = method->name();
    (*vars)["Response"] =
        grpc_cpp_generator::ClassName(method->output_type(), true);

    printer->Print(*vars,
                 "    case $Idx$:\n");

    if (NoStreaming(method)) {
      printer->Print(*vars,
                 "      if (!request_buffer) return;\n"
                 "      $Method$(*request_buffer,\n"
                 "          $Method$_Replier(call_sptr));\n");
    } else if (ServerOnlyStreaming(method)) {
      printer->Print(*vars,
                 "      if (!request_buffer) return;\n"
                 "      $Method$(*request_buffer,\n"
                 "          $Method$_Writer(call_sptr));\n");
    } else {
      printer->Print(*vars,
                 "      assert(!request_buffer);\n"
                 "      $Method$(call_sptr);\n");
    }  // if

    printer->Print(
                 "      return;\n");
  }  // for
  printer->Print("  }  // switch\n"
                 "  assert(false);\n"
                 "  (void)request_buffer;\n"
                 "  (void)call_sptr;\n"
                 "}\n\n");
}

void PrintSourceService(grpc::protobuf::io::Printer *printer,
                        const grpc::protobuf::ServiceDescriptor *service,
                        std::map<grpc::string, grpc::string> *vars) {
  (*vars)["Service"] = service->name();
  printer->Print(*vars,
                 "namespace $Service$ {  // service $Service$\n"
                 "\n");
  printer->Print(*vars,
                 "static const std::string method_names[] = {\n");
  for (int i = 0; i < service->method_count(); ++i) {
    (*vars)["Method"] = service->method(i)->name();
    printer->Print(*vars, "  \"/$Package$$Service$/$Method$\",\n");
  }
  printer->Print(*vars, "};\n\n");

  printer->Print(*vars,
                 "const ::google::protobuf::ServiceDescriptor& GetServiceDescriptor() {\n"
                 "  AssignDescriptorsOnce();\n"
                 "  assert(service_descriptor_$Service$);\n"
                 "  return *service_descriptor_$Service$;\n"
                 "}\n\n");

  printer->Print(*vars,
                 "Stub::Stub(const ::grpc_cb::ChannelSptr& channel,\n"
                 "    const ::grpc_cb::CompletionQueueForNextSptr& cq4n_sptr)\n"
                 "    : ::grpc_cb::ServiceStub(channel, cq4n_sptr) {}\n\n");

  for (int i = 0; i < service->method_count(); ++i) {
    (*vars)["Idx"] = as_string(i);
    PrintSourceClientMethod(printer, service->method(i), vars);
  }

  (*vars)["MethodCount"] = as_string(service->method_count());

  printer->Print(*vars,
                 "Service::Service() {}\n\n"
                 "Service::~Service() {}\n\n");

  printer->Print("const std::string& Service::GetMethodName(size_t method_index) const {\n"
                  "  assert(method_index < GetMethodCount());\n"
                  "  return method_names[method_index];\n"
                  "}\n\n");

  PrintCallMethod(printer, service, vars);

  for (int i = 0; i < service->method_count(); ++i) {
    (*vars)["Idx"] = as_string(i);
    PrintSourceServerMethod(printer, service->method(i), vars);
  }
  printer->Print(*vars,
                 "}  // namespace $Service$\n\n");
}

grpc::string GetSourceServices(const grpc::protobuf::FileDescriptor *file,
                               const Parameters &params) {
  grpc::string output;
  {
    // Scope the output stream so it closes and finalizes output to the string.
    grpc::protobuf::io::StringOutputStream output_stream(&output);
    grpc::protobuf::io::Printer printer(&output_stream, '$');
    std::map<grpc::string, grpc::string> vars;
    // Package string is empty or ends with a dot. It is used to fully qualify
    // method names.
    vars["Package"] = file->package();
    if (!file->package().empty()) {
      vars["Package"].append(".");
    }

    for (int i = 0; i < file->service_count(); ++i) {
      PrintSourceService(&printer, file->service(i), &vars);
    }
  }
  return output;
}

grpc::string GetSourceEpilogue(const grpc::protobuf::FileDescriptor *file,
                               const Parameters &params) {
  grpc::string temp;

  if (!file->package().empty()) {
    std::vector<grpc::string> parts =
        grpc_generator::tokenize(file->package(), ".");

    for (auto part = parts.begin(); part != parts.end(); part++) {
      temp.append("}  // namespace ");
      temp.append(*part);
      temp.append("\n");
    }
    temp.append("\n");
  }

  return temp;
}

}  // namespace grpc_cpp_cb_generator
